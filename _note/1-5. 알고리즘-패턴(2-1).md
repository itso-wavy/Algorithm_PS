# 3. 알고리즘

## (2) 문제 해결 전략

### 2.1) 투(멀티) 포인터 패턴

- 정렬된 배열에서 여러 포인터를 특정 방향으로 이동하면서 값을 비교
- `선형 구조`/`단일 연결 리스트`/`이중 연결 리스트`에서 사용

#### practice

> **Multiple Pointers - countUniqueValues**

Implement a function called countUniqueValues, which accepts a sorted array, and counts the unique values in the array. There can be negative numbers in the array, but it will always be sorted.

Bonus: You must do this with O(1) space and O(n) time.

```ts
countUniqueValues([1,1,1,1,1,2]) // 2
countUniqueValues([1,2,3,4,4,4,7,7,12,12,13]) // 7
countUniqueValues([]) // 0
countUniqueValues([-2,-1,-1,0,1]) // 4

Time Complexity - O(n)
Space Complexity - O(1)
```

```ts
/**
 * arr의 원소 중 중복을 무시하고 고유 원소의 개수만 반환하는 함수
 * 경계조건: 길이가 0인 배열
 * @param arr number[]
 * @returns number
 */
function countUniqueValues(arr) {
  // arr의 길이가 0일 때 예외처리
  if (arr.length < 1) return arr.length;

  // 정렬된 배열로 시작
  arr.sort();

  // 두 포인터 지정
  let index1 = 0;
  let index2 = 1;
  // 루프를 돌려 포인터1과 포인터2를 이동하며 비교
  // 선두인 포인터2가 배열 끝에 다다를 때까지
  while (index2 < arr.length) {
    // 포인터1은 고유값, 포인터2는 비교값
    if (arr[index1] !== arr[index2]) {
      ++index1;
      arr[index1] = arr[index2];
    }
    ++index2;
  }
  return index1 + 1;
}
```
